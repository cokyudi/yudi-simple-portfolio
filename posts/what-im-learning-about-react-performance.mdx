---
title: "What Iâ€™m Learning About React Performance Optimization"
date: "2026-01-14"
description: "Notes from my ongoing journey of understanding React performanceâ€”re-renders, memoization, and how Iâ€™m learning to optimize React apps more intentionally."
---

## Introduction

Iâ€™ve been using React for years, but recently I realized something uncomfortable:

I couldnâ€™t clearly explain *why* some components re-render and others donâ€™t.

Sure, I knew about `useMemo`, `useCallback`, and `React.memo`. I had used them before.  
But my understanding felt shallowâ€”more like following patterns than truly knowing *when* and *why* to use them.

So I decided to slow down and really learn **React performance optimization**, starting from the basics.

This post is a summary of what Iâ€™m learning so farâ€”not as an expert, but as someone rebuilding their mental model of how React actually works.

---

## What React Performance Means to Me Now

When I first heard â€œReact optimization,â€ I thought it meant:

> Make everything faster by using memoization.

Now I see it differently.

React performance is more about:
- Understanding **why components re-render**
- Knowing when re-renders are *fine*
- Avoiding **unnecessary work**, not all work
- Writing predictable, readable components first

React is already fast by default. Optimization is about *intent*, not panic.

---

## Re-renders Are Not the Enemy

One important thing Iâ€™m learning:  
**Re-renders are normal.**

A component re-renders when:
- Its state changes
- Its props change
- Its parent re-renders
- Context it uses updates

This doesnâ€™t automatically mean something is wrong.

By default, when a parent re-renders, **all of its children re-render too**.
```tsx
Parent Component
   â”œâ”€â”€ Child A
   â””â”€â”€ Child B
```
When `Parent` state changes:
```tsx
Parent Component  ğŸ”„
   â”œâ”€â”€ Child A     ğŸ”„
   â””â”€â”€ Child B     ğŸ”„
```
Even if `Child A` and `Child B` donâ€™t use the updated state, they still re-render.

This is normal React behavior â€” and often totally fine.

Reactâ€™s reconciliation is efficient, and many re-renders are cheap.  
The real problem is **expensive calculations or large component trees re-rendering unnecessarily**.

Understanding this alone changed how I think about optimization.

---

## React.memo: Helpful, but Not Magic

Now letâ€™s wrap `Child A` with `React.memo`.
```tsx
Parent Component
   â”œâ”€â”€ Child A (memoized)
   â””â”€â”€ Child B
```
If Parent re-renders **but Child Aâ€™s props donâ€™t change**:
```tsx
Parent Component  ğŸ”„
   â”œâ”€â”€ Child A     â¸ï¸ (skipped)
   â””â”€â”€ Child B     ğŸ”„
```
This is where `React.memo` helps:
- It prevents unnecessary work
- Only when props stay referentially equal

At first, I thought `React.memo` was an easy performance win.

Now I know:
- `React.memo` prevents re-render **only if props are referentially equal**
- If props change every render, it does nothing
- It adds complexity and comparison cost

A simple example:

```tsx
const ItemList = React.memo(({ items }) => {
  return items.map(item => <Item key={item.id} {...item} />);
});
```

This helps only if items doesnâ€™t change on every render.

Iâ€™m learning to use React.memo after identifying a real problemâ€”not by default.

---

## useMemo Is About Values, Not Speed

One misconception I had:  
`useMemo` makes things faster.

What Iâ€™m learning now:

- `useMemo` memoizes a **value**
- Itâ€™s useful for **expensive calculations**
- It wonâ€™t magically optimize simple logic

Example:
```tsx
const sortedItems = useMemo(() => {
  return items.sort((a, b) => a.price - b.price);
}, [items]);
```

This makes sense when:

- The calculation is expensive
- The dependencies are stable
- The memoized value is reused

Using `useMemo` everywhere just adds noise.

Without `useMemo`:
```tsx
Render
 â””â”€â”€ expensiveCalculation() ğŸ’¸ every time
```

With `useMemo`:
```tsx
Render
 â”œâ”€â”€ dependencies changed? â†’ recompute
 â””â”€â”€ dependencies same?    â†’ reuse cached value
```

Visualized:
```tsx
State change unrelated
 â””â”€â”€ useMemo value reused âœ…
```

This helped me stop using `useMemo` blindly and start asking:

> Is this calculation actually expensive?

---

## useCallback Finally Makes Sense

`useCallback` confused me for a long time.

Now I understand it better:
- It memoizes **function references**
- It matters when passing callbacks to memoized children
- Itâ€™s about **identity**, not behavior

```tsx
const handleClick = useCallback(() => {
  setCount(c => c + 1);
}, []);
```
This helps when `handleClick` is passed down to a component wrapped with `React.memo`.

Without that context, `useCallback` often doesnâ€™t helpâ€”and can even hurt readability.

A common mistake (one I made many times):
```tsx
Parent
 â””â”€â”€ Child (memoized)
```

But the parent passes a **new function every render**:
```tsx
Parent re-render
 â””â”€â”€ onClick = () => {}  âŒ new reference
```

Result:
```tsx
Parent Component  ğŸ”„
   â””â”€â”€ Child       ğŸ”„ (props changed!)
```

Now with useCallback:
```tsx
Parent re-render
 â””â”€â”€ onClick = useCallback(...) âœ… same reference
```

Result:
```tsx
Parent Component  ğŸ”„
   â””â”€â”€ Child       â¸ï¸ (skipped)
```

This diagram finally made `useCallback` â€œclickâ€ for me:
ğŸ‘‰ Itâ€™s about **function identity**, not logic.

---
## Keys and Lists: Small Detail, Big Impact

Another lesson Iâ€™m revisiting: **keys matter more than I thought**.

Using array indexes as keys can:

- Break component state
- Cause unnecessary re-renders
- Create subtle UI bugs

Stable, unique keys help React understand what actually changed.

Itâ€™s a small detail, but it has a big impact on performance and correctness.

Using **index as key**:
```tsx
Before:
[ A, B, C ]
 0  1  2

After removing A:
[ B, C ]
 0  1
```

React thinks:
```tsx
A â†’ B
B â†’ C
```

Result:
- Wrong component reused
- State bugs
- Extra re-renders

Using **stable IDs**:
```tsx
Before:
[ A(id=1), B(id=2), C(id=3) ]

After removing A:
[ B(id=2), C(id=3) ]
```

React correctly understands:
```tsx
A removed
B unchanged
C unchanged
```

This small change can prevent **many subtle bugs**.

---

## Mistakes Iâ€™ve Personally Made

Looking back, here are a few mistakes Iâ€™ve madeâ€”and still catch myself making sometimes:
- Using `useMemo` and `useCallback` â€œjust in caseâ€
- Optimizing before measuring anything
- Copying patterns without understanding them
- Ignoring React DevTools Profiler

None of these are dramatic mistakes, but they add up.

<Figure
  src="/images/blog/react-meme.webp"
  alt="React developer adding useMemo and useCallback everywhere and still seeing re-renders"
  caption="How I feel when creating new React component"
  priority
/>

---

## Final Thoughts

React optimization isnâ€™t about clever tricks or fancy hooks.

For me, itâ€™s about:
- Understanding how React thinks
- Writing simple, predictable components
- Optimizing with intention, not fear

This post is just a snapshot of what Iâ€™m learning right nowâ€”and Iâ€™m sure Iâ€™ll look back at it later with new insights.

Thanks for reading. Iâ€™ll keep learning, building, and sharing along the way ğŸ™
